package com.minekarta.advancedcorerealms.data;

import com.minekarta.advancedcorerealms.AdvancedCoreRealms;
import com.minekarta.advancedcorerealms.data.object.Realm;
import org.bukkit.Bukkit;
import org.bukkit.OfflinePlayer;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.InvalidConfigurationException;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.logging.Level;

public class WorldDataManager {

    private final AdvancedCoreRealms plugin;
    private final File worldsFile;
    private FileConfiguration worldsConfig;
    private final Map<String, Realm> realms;

    public WorldDataManager(AdvancedCoreRealms plugin) {
        this.plugin = plugin;
        this.worldsFile = new File(plugin.getDataFolder(), "worlds.yml");
        this.realms = new HashMap<>();
    }

    /**
     * Ensures that the worlds.yml file exists in the plugin's data folder.
     * If it doesn't exist, it tries to save the default resource from the JAR.
     * This makes the plugin robust against missing configuration files.
     */
    private void ensureWorldsFileExists() {
        if (worldsFile.exists()) {
            return;
        }

        plugin.getLogger().info("worlds.yml not found, creating a new one with default values...");
        try {
            // The 'false' argument prevents overwriting an existing file,
            // but we've already checked for that. This call extracts the
            // default worlds.yml from the plugin's JAR.
            plugin.saveResource("worlds.yml", false);
        } catch (IllegalArgumentException e) {
            // This catch block handles the case where the resource is not in the JAR.
            // We'll create the file programmatically with default content.
            plugin.getLogger().warning("Could not find 'worlds.yml' in the JAR. Creating a default file manually.");
            try {
                // Ensure the parent directory exists.
                worldsFile.getParentFile().mkdirs();

                FileConfiguration newWorldsConfig = new YamlConfiguration();
                newWorldsConfig.options().header(
                    "# Default worlds configuration for AdvancedCoreRealms.\n" +
                    "# This file is automatically generated if it's missing."
                );
                newWorldsConfig.options().copyHeader(true);

                newWorldsConfig.set("worlds.sampleRealm.owner", "YourName");
                newWorldsConfig.set("worlds.sampleRealm.type", "VANILLA");
                newWorldsConfig.set("worlds.sampleRealm.borderSize", 50);

                // Save the new configuration to the file
                newWorldsConfig.save(worldsFile);
                plugin.getLogger().info("Successfully created a default worlds.yml.");
            } catch (IOException ioException) {
                plugin.getLogger().log(Level.SEVERE, "Failed to create a default worlds.yml file.", ioException);
            }
        }
    }

    public void loadData() {
        ensureWorldsFileExists();

        this.worldsConfig = YamlConfiguration.loadConfiguration(worldsFile);

        // For backward compatibility, check for "realms" if "worlds" is not present.
        ConfigurationSection realmsSection = worldsConfig.getConfigurationSection("worlds");
        if (realmsSection == null) {
            realmsSection = worldsConfig.getConfigurationSection("realms");
            if (realmsSection != null) {
                plugin.getLogger().info("Found legacy 'realms' section. It will be migrated to 'worlds' on the next save.");
            } else {
                plugin.getLogger().info("No realms found in worlds.yml. This is normal on first run.");
                return;
            }
        }

        for (String realmId : realmsSection.getKeys(false)) {
            String path = realmsSection.getName() + "." + realmId;
            String name = worldsConfig.getString(path + ".name", realmId);

            // Gracefully handle owner parsing from UUID or player name
            UUID owner = null;
            String ownerIdentifier = worldsConfig.getString(path + ".owner");
            if (ownerIdentifier != null && !ownerIdentifier.isEmpty()) {
                try {
                    owner = UUID.fromString(ownerIdentifier);
                } catch (IllegalArgumentException e) {
                    OfflinePlayer player = Bukkit.getOfflinePlayer(ownerIdentifier);
                    owner = player.getUniqueId();
                    plugin.getLogger().info("Resolved owner name '" + ownerIdentifier + "' to UUID: " + owner);
                }
            }

            if (owner == null) {
                plugin.getLogger().warning("Could not determine owner for realm '" + name + "'. Skipping this entry.");
                continue;
            }

            String worldName = worldsConfig.getString(path + ".worldName", name + "_world");
            String template = worldsConfig.getString(path + ".template", worldsConfig.getString(path + ".type", "default")); // Support "type" for new format

            Instant createdAt;
            try {
                String createdAtStr = worldsConfig.getString(path + ".createdAt");
                createdAt = createdAtStr != null ? Instant.parse(createdAtStr) : Instant.now();
            } catch (DateTimeParseException e) {
                plugin.getLogger().warning("Invalid 'createdAt' timestamp for realm " + name + ". Using current time as a fallback.");
                createdAt = Instant.now();
            }

            boolean isFlat = worldsConfig.getBoolean(path + ".isFlat", false);
            Realm realm = new Realm(name, owner, worldName, template, createdAt, isFlat);

            // Load upgrade fields with defaults
            realm.setDifficulty(worldsConfig.getString(path + ".difficulty", "normal"));
            realm.setKeepLoaded(worldsConfig.getBoolean(path + ".keepLoaded", false));
            realm.setBorderTierId(worldsConfig.getString(path + ".borderTierId", "tier_50"));
            realm.setMemberSlotTierId(worldsConfig.getString(path + ".memberSlotTierId", "tier_0"));
            realm.setBorderSize(worldsConfig.getInt(path + ".borderSize", 100));
            realm.setMaxPlayers(worldsConfig.getInt(path + ".maxPlayers", 8));

            // Load members
            ConfigurationSection membersSection = worldsConfig.getConfigurationSection(path + ".members");
            if (membersSection != null) {
                for (String memberUuid : membersSection.getKeys(false)) {
                    try {
                        com.minekarta.advancedcorerealms.realm.Role role = com.minekarta.advancedcorerealms.realm.Role.valueOf(membersSection.getString(memberUuid));
                        realm.addMember(UUID.fromString(memberUuid), role);
                    } catch (IllegalArgumentException e) {
                        plugin.getLogger().warning("Invalid role or UUID for member " + memberUuid + " in realm " + name);
                    }
                }
            }

            realms.put(name, realm);
        }
        plugin.getLogger().info("Loaded " + realms.size() + " realms from data file.");
    }

    public void saveData() {
        // To perform a clean migration, we remove the old key if it exists.
        if (worldsConfig.isConfigurationSection("realms")) {
            worldsConfig.set("realms", null);
        }

        // The new root for all data is "worlds". Clear it before saving.
        worldsConfig.set("worlds", null);

        // Save all realms to file under the "worlds" section
        for (Realm realm : realms.values()) {
            String path = "worlds." + realm.getName();
            worldsConfig.set(path + ".name", realm.getName());
            worldsConfig.set(path + ".owner", realm.getOwner().toString());
            worldsConfig.set(path + ".worldName", realm.getWorldName());
            worldsConfig.set(path + ".template", realm.getTemplate());
            worldsConfig.set(path + ".createdAt", realm.getCreatedAt().toString());
            worldsConfig.set(path + ".isFlat", realm.isFlat());

            // Save new upgrade fields
            worldsConfig.set(path + ".difficulty", realm.getDifficulty());
            worldsConfig.set(path + ".keepLoaded", realm.isKeepLoaded());
            worldsConfig.set(path + ".borderTierId", realm.getBorderTierId());
            worldsConfig.set(path + ".memberSlotTierId", realm.getMemberSlotTierId());
            worldsConfig.set(path + ".borderSize", realm.getBorderSize());
            worldsConfig.set(path + ".maxPlayers", realm.getMaxPlayers());

            // Save members
            if (realm.getMembers() != null && !realm.getMembers().isEmpty()) {
                for (Map.Entry<UUID, com.minekarta.advancedcorerealms.realm.Role> entry : realm.getMembers().entrySet()) {
                    worldsConfig.set(path + ".members." + entry.getKey().toString(), entry.getValue().name());
                }
            } else {
                worldsConfig.set(path + ".members", null);
            }

            worldsConfig.set(path + ".transferable-items", realm.getTransferableItems());
        }

        try {
            worldsConfig.save(worldsFile);
        } catch (IOException e) {
            plugin.getLogger().severe("Could not save worlds.yml file: " + e.getMessage());
        }
    }

    public void saveDataAsync() {
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            saveData();
            plugin.getLogger().info("Saved " + realms.size() + " realms to data file asynchronously.");
        });
    }

    public void addRealm(Realm realm) {
        realms.put(realm.getName(), realm);
        saveDataAsync();
    }

    public void removeRealm(String realmName) {
        realms.remove(realmName);
        saveDataAsync();
    }

    public Realm getRealm(String realmName) {
        return realms.get(realmName);
    }

    public List<Realm> getAllRealms() {
        return new ArrayList<>(realms.values());
    }

    public List<Realm> getPlayerRealms(UUID playerId) {
        List<Realm> playerRealms = new ArrayList<>();
        for (Realm realm : realms.values()) {
            if (realm.getOwner().equals(playerId)) {
                playerRealms.add(realm);
            }
        }
        return playerRealms;
    }

    public List<Realm> getPlayerInvitedRealms(UUID playerId) {
        List<Realm> invitedRealms = new ArrayList<>();
        for (Realm realm : realms.values()) {
            if (realm.getMembers().containsKey(playerId) && !realm.getOwner().equals(playerId)) {
                invitedRealms.add(realm);
            }
        }
        return invitedRealms;
    }

    public boolean isPlayerInRealm(UUID playerId, String realmName) {
        Realm realm = getRealm(realmName);
        return realm != null && realm.isMember(playerId);
    }

    public Optional<Realm> getRealmByWorldName(String worldName) {
        return realms.values().stream()
                .filter(realm -> worldName.equals(realm.getWorldName()))
                .findFirst();
    }
}